{"componentChunkName":"component---src-templates-tag-page-js","path":"/tag/Compiler","result":{"data":{"site":{"siteMetadata":{"title":"Twistronics Blog"}},"allMarkdownRemark":{"edges":[{"node":{"fields":{"slug":"/blogs/Compiler-3/"},"frontmatter":{"title":"Compiler (3)：翻译成中间代码","date":"October 09, 2015","description":"由于源语言和目标语言一般有比较大的差别，因此直接把语法树翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。","tags":["Java","Compiler"]}}},{"node":{"fields":{"slug":"/blogs/Compiler-2/"},"frontmatter":{"title":"Compiler (2)：语义分析","date":"October 04, 2015","description":"能够成功建立语法树只说明了所输入的 Decaf 源程序在格式上是合法的，但是要进行有效的翻译，编译器还需要了解这个程序每个语句的含义。了解程序含义的过程称为语义分析。","tags":["Java","Compiler","YACC","LEX"]}}},{"node":{"fields":{"slug":"/blogs/Compiler-1/"},"frontmatter":{"title":"Compiler (1)：词法分析、语法分析及抽象语法树生成","date":"September 24, 2015","description":"实现一个非常简单的 Decaf 编译器。这个编译器的输入是 Decaf 源语言程序，输出是 MIPS R2000/R3000 伪指令汇编程序。掌握 LEX 和 YACC 的用法，体会正规表达式、自动机、LALR(1)分析等理论是如何在实践中得到运用的","tags":["Java","Compiler","YACC","LEX"]}}}]}},"pageContext":{"tag":"Compiler"}}}